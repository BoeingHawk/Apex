ğŸ“Œ Future Method in Apex
ğŸ”¹ What is a Future Method?
A Future Method in Apex allows you to run a piece of code asynchronously (in the background) after the current transaction completes. This is useful when you need to:
âœ… Perform long-running operations (like calling an external system).
âœ… Avoid governor limits in a synchronous transaction.
âœ… Improve user experience by executing non-urgent tasks later.


ğŸ”¹ How to Declare a Future Method?
âœ… Basic Syntax
apex
Copy
Edit
global class FutureExample {
    @future
    public static void myFutureMethod(String name) {
        System.debug('Hello, ' + name);
    }
}

Key Points:
âœ” @future â†’ Tells Salesforce this method should run asynchronously.
âœ” public static â†’ Must be static because it's called without instantiating the class.

âœ… Calling the Future Method
apex
Copy
Edit
FutureExample.myFutureMethod('Pulkit');
When this code runs, the method does not execute immediately but is queued in the background.

ğŸ”¹ When to Use Future Methods?
You should use a future method when:
âœ” You need to call an external system (API Callout) after the transaction completes.
âœ” You are hitting governor limits in a synchronous transaction.
âœ” You want to process a large amount of data asynchronously.


ğŸ”¹ Example Use Cases
âœ… 1. Performing a Callout After a DML Operation
Apex does not allow callouts after a DML (Database) operation in a synchronous transaction.
Using a future method solves this issue.

âŒ Without Future Method (Fails)
apex
Copy
Edit
public class CalloutExample {
    public static void makeCallout() {
        insert new Account(Name = 'Test Account'); // DML Operation
        HttpRequest req = new HttpRequest(); // API Callout
        // This will FAIL due to mixed DML and callout
    }
}
âœ… With Future Method (Works)
apex
Copy
Edit
global class CalloutExample {
    @future(callout=true) 
    public static void makeCallout() {
        HttpRequest req = new HttpRequest();
        System.debug('Making API callout...');
    }
}
Here, callout=true allows the method to make an API call.

âœ… 2. Processing Large Data Sets
If a trigger processes too many records, a governor limit error occurs.
Using future methods helps break up processing.

âŒ Trigger Without Future Method (Governor Limit Error)
apex
Copy
Edit
trigger AccountTrigger on Account (after insert) {
    for (Account acc : Trigger.new) {
        acc.Name = acc.Name + ' Updated';
        update acc; // âŒ Too many DML statements!
    }
}
âœ… Trigger Using Future Method (Efficient)
apex
Copy
Edit
trigger AccountTrigger on Account (after insert) {
    FutureExample.updateAccounts(Trigger.newMap.keySet());
}

global class FutureExample {
    @future
    public static void updateAccounts(Set<Id> accountIds) {
        List<Account> accs = [SELECT Id, Name FROM Account WHERE Id IN :accountIds];
        for (Account acc : accs) {
            acc.Name += ' Updated';
        }
        update accs; // âœ… Processes all records asynchronously
    }
}
ğŸ”¹ Limitations of Future Methods
While future methods are powerful, they have some limitations:

ğŸ”´ Cannot return values â†’ They must be void.
ğŸ”´ Cannot be called inside another future method (No chaining).
ğŸ”´ Cannot handle complex objects like sObject as parameters â†’ Use Id lists instead.
ğŸ”´ Governor Limits Apply â†’ You can only have 50 future calls per transaction.
ğŸ”´ Cannot use inside Batch Apex â†’ Use Queueable Apex instead.

ğŸ”¹ Best Practices
âœ” Use future methods only when necessary to avoid hitting limits.
âœ” Pass only IDs or primitive data types as parameters.
âœ” Use Queueable Apex if you need chaining or returning results.
âœ” Monitor future jobs in Setup â†’ Apex Jobs.

ğŸ¯ Final Summary
Feature	Details
Runs Asynchronously?	âœ… Yes
Can return values?	âŒ No
Can call API Callouts?	âœ… Yes (if callout=true)
Can pass sObject?	âŒ No (Pass Id instead)
Maximum per transaction	âŒ 50 Future calls
Supports Chaining?	âŒ No (Use Queueable Apex)
ğŸš€ Future Methods help run heavy operations asynchronously and avoid governor limits. But for more control (chaining, returning values), Queueable Apex is better!

Let me know if you need further explanation! ğŸ˜Š
